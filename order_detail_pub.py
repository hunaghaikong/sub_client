#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time    : 2017/12/29 0029 14:57# @Author  : Hadrianl # @File    : order_detail_pub.py# @License : (C) Copyright 2013-2017, 凯瑞投资"""该脚本为新单变化的推送发布端，对接的数据库，以及开放的发布端口可在conf.ini里设置,ini内默认port为5000"""import pymysql as pmimport timeimport configparserfrom colorama import Fore, Back, initimport asyncioimport zmqfrom zmq.asyncio import Context, ZMQEventLoopimport sysfrom datetime import datetimeimport loggingimport logging.configlogging.config.fileConfig('log.conf')logger = logging.getLogger('order_publish')init(autoreset=True)conf = configparser.ConfigParser()try:    conf.read('conf.ini')    dbconfig = {'host': conf.get('MYSQL', 'host'),                'port': conf.getint('MYSQL', 'port'),                'user': conf.get('MYSQL', 'user'),                'password': conf.get('MYSQL', 'password'),                'db': conf.get('MYSQL', 'db'),                'cursorclass': pm.cursors.DictCursor,                }    zmq_port = conf.getint('ZMQ', 'port')    conn = pm.connect(**dbconfig)except Exception:    logger.exception('初始化连接失败！')    time.sleep(10)    sys.exit()try:    with conn.cursor() as cursor:        sql = 'select MAX(OpenTime) as init_time from order_detail'        cursor.execute(sql)        last_time = cursor.fetchone()['init_time']        conn.commit()except Exception as e:    logger.warning('初始化最新订单时间失败！设为当前时间')    last_time = datetime.now()async def run_pub():    global last_time    orders_dict = {}    with pub(zmq_port) as p:        while True:            with conn.cursor() as cursor:                try:                    sql = f'select * from order_detail where OpenTime>"{last_time}"'                    cursor.execute(sql)                    new_orders = cursor.fetchall()                    if new_orders:                        last_time = max([d.get('OpenTime') for d in new_orders])                        for d in new_orders:                            orders_dict.update({d.get('Ticket'): d})                            await p.send_changed_order(d)                    remaining_orders = [str(t) for t, v in orders_dict.items() if                                        v.get('Status') == 1 or v.get('Status') == 0]                    if remaining_orders:                        sql = f'select * from order_detail where Ticket in ({",".join(remaining_orders)}) and CloseTime>"1970-01-01 00:00:00"'                        cursor.execute(sql)                        closed_orders = cursor.fetchall()                        if closed_orders:                            for d in closed_orders:                                orders_dict.update({d.get('Ticket'): d})                                await p.send_changed_order(d)                except Exception as e:                    logger.exception('发布新订单失败！')                    raise e                finally:                    conn.commit()                    time.sleep(0.5)class pub():    def __init__(self, port):        self.context = Context()        self.socket = self.context.socket(zmq.PUB)        self.socket.bind(f"tcp://*:{port}")        self._port = port    async def send_changed_order(self, d: dict):        if d.get('Status') == 1:            log_info = f'账户:{d.get("Account_ID")}--于{d.get("OpenTime")}开仓--{d.get("Symbol")}@{d.get("OpenPrice")}-#{d.get("Ticket")}'        elif d.get('Status') == 0:            log_info = f'账户:{d.get("Account_ID")}--于{d.get("OpenTime")}挂单--{d.get("Symbol")}@{d.get("OpenPrice")}-#{d.get("Ticket")}'        elif d.get('Status') == -1:            log_info = f'账户:{d.get("Account_ID")}--于{d.get("OpenTime")}取消挂单--{d.get("Symbol")}@{d.get("OpenPrice")}-#{d.get("Ticket")}'        elif d.get('Status') == 2:            tp = d.get('Comment').find('[tp]') != -1            sl = d.get('Comment').find('[sl]') != -1            has_comment = bool(d.get('Comment'))            close_type = {0: '平仓', 1: d.get('Comment'), 2: '止损', 3: '止盈', 4: d.get('Comment')}.get(((tp << 1) + sl + 1) * has_comment)            log_info = f'账户:{d.get("Account_ID")}--于{d.get("OpenTime")}{close_type}--{d.get("Symbol")}@{d.get("OpenPrice")}-#{d.get("Ticket")}'        else:            log_info = f'Status:{d.get("Status")}'        logger.info(log_info)        await self.socket.send_pyobj(d)    def __enter__(self):        logger.info(f'最新订单时间为{last_time}')        logger.info(f'订阅端口----*:{self._port}')        logger.info('开启订阅推送')        return self    def __exit__(self, exc_type, exc_val, exc_tb):        self.socket.close()        logger.info('关闭订阅推送')def main():    try:        loop = ZMQEventLoop()        asyncio.set_event_loop(loop)        loop.run_until_complete(run_pub())    except KeyboardInterrupt:        print(f'{Fore.RED}发布终止{Fore.RESET}')        time.sleep(3)if __name__ == '__main__':    main()